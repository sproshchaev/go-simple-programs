package main

import (
	"errors"
	"fmt"
)

func main() {
    result, err := GetCharacterAtPosition("Оле ола вперёд Спартак Москва", 0)
    if err != nil {
        fmt.Println(result, err)
    } else {
        fmt.Println(result, err) // Выводим код руны
    }
}

// Напишите функцию GetCharacterAtPosition(str string, position int) (rune, error) для робота-помощника,
// которая получает на вход строку и целое число. Функция должна возвращать символ строки, который находится на позиции,
// указанной пользователем (и nil в качестве ошибки). Если пользователь ввёл число, которое выходит за пределы длины строки,
// функция должна возвращать в качестве ответа нулевую руну (0) сообщение об ошибке (position out of range).
// Примечания: Как настоящий программист Гоша начинает нумерацию с 0. И напоминаем про руны.
func GetCharacterAtPosition(str string, position int) (rune, error) {
	// строка в Go хранится в виде последовательности байтов (в кодировке UTF-8), а символы, занимающие более одного байта (как, например, символы кириллицы), 
	// представляются несколькими байтами. Когда вы пытаетесь получить символ с помощью str[position], вы получаете байт, 
	// а не полноценную руну (символ Unicode).
    // Для решения этой проблемы нужно использовать индексирование по рунам, а не по байтам. 
	runes := []rune(str) // Преобразуем строку в массив рун
	if position < 0 || position >= len(runes) {
		// возвращать в качестве ответа нулевую руну (0) сообщение об ошибке (position out of range)
		return 0, errors.New("position out of range")
	} else {
		return runes[position], nil // Возвращаем руну и nil как отсутствие ошибки
	}
}
